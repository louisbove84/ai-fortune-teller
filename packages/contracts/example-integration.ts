/**
 * Example: How to interact with ProphecyToken from your Next.js app
 * 
 * This file shows examples of integrating the deployed contract with your app.
 * Place similar code in apps/web/src/lib/contracts.ts or an API route.
 */

import { createPublicClient, http, parseAbi } from "viem";
import { base, baseSepolia } from "viem/chains";

// Contract ABI (auto-generated by Hardhat, or extract from artifacts)
const PROPHECY_TOKEN_ABI = parseAbi([
  "function mintProphecy(address to, string memory tokenURI, uint256 score, string memory occupation) external returns (uint256)",
  "function updateProphecy(uint256 tokenId, string memory newTokenURI, uint256 newScore) external",
  "function getProphecy(uint256 tokenId) external view returns (tuple(uint256 resilienceScore, string occupation, uint256 timestamp, uint256 updateCount, address recipient))",
  "function getCurrentTokenId() external view returns (uint256)",
  "function owner() external view returns (address)",
  "event ProphecyMinted(address indexed to, uint256 indexed tokenId, uint256 resilienceScore, string occupation, string tokenURI)",
  "event ProphecyUpdated(uint256 indexed tokenId, uint256 newScore, string newTokenURI)",
]);

// Contract address (set after deployment)
const CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_NFT_CONTRACT_ADDRESS || "";

// Initialize public client for read operations (Base mainnet L2)
const publicClient = createPublicClient({
  chain: base, // Base mainnet (L2)
  transport: http(process.env.BASE_RPC_URL || "https://mainnet.base.org"),
});

/**
 * Example 1: Read prophecy data
 */
export async function getProphecyData(tokenId: bigint) {
  try {
    const data = await publicClient.readContract({
      address: CONTRACT_ADDRESS as `0x${string}`,
      abi: PROPHECY_TOKEN_ABI,
      functionName: "getProphecy",
      args: [tokenId],
    });

    return {
      resilienceScore: Number(data.resilienceScore),
      occupation: data.occupation,
      timestamp: Number(data.timestamp),
      updateCount: Number(data.updateCount),
      recipient: data.recipient,
    };
  } catch (error) {
    console.error("Error reading prophecy:", error);
    throw error;
  }
}

/**
 * Example 2: Mint NFT (requires wallet connection and owner account)
 * 
 * Use this in an API route or server-side only!
 * For client-side minting, use Wagmi hooks with wallet connection.
 */
export async function mintProphecyNFT(
  walletClient: any, // Wagmi wallet client
  recipient: `0x${string}`,
  tokenURI: string,
  score: number,
  occupation: string
) {
  try {
    const hash = await walletClient.writeContract({
      address: CONTRACT_ADDRESS as `0x${string}`,
      abi: PROPHECY_TOKEN_ABI,
      functionName: "mintProphecy",
      args: [recipient, tokenURI, BigInt(score), occupation],
    });

    // Wait for transaction confirmation
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    return {
      txHash: hash,
      receipt,
      tokenId: receipt.logs[0]?.topics[3] ? BigInt(receipt.logs[0].topics[3]) : null,
    };
  } catch (error) {
    console.error("Error minting NFT:", error);
    throw error;
  }
}

/**
 * Example 3: Update prophecy (requires owner account)
 */
export async function updateProphecy(
  walletClient: any,
  tokenId: bigint,
  newTokenURI: string,
  newScore: number
) {
  try {
    const hash = await walletClient.writeContract({
      address: CONTRACT_ADDRESS as `0x${string}`,
      abi: PROPHECY_TOKEN_ABI,
      functionName: "updateProphecy",
      args: [tokenId, newTokenURI, BigInt(newScore)],
    });

    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    return { txHash: hash, receipt };
  } catch (error) {
    console.error("Error updating prophecy:", error);
    throw error;
  }
}

/**
 * Example 4: Listen for mint events
 */
export async function watchProphecyMints(callback: (event: any) => void) {
  publicClient.watchContractEvent({
    address: CONTRACT_ADDRESS as `0x${string}`,
    abi: PROPHECY_TOKEN_ABI,
    eventName: "ProphecyMinted",
    onLogs: (logs) => {
      logs.forEach((log) => {
        callback({
          to: log.args.to,
          tokenId: log.args.tokenId,
          score: Number(log.args.resilienceScore),
          occupation: log.args.occupation,
        });
      });
    },
  });
}

/**
 * Example usage in a Next.js API route (apps/web/src/app/api/nft/mint/route.ts):
 * 
 * ```typescript
 * import { createWalletClient, http } from "viem";
 * import { privateKeyToAccount } from "viem/accounts";
 * import { base } from "viem/chains";
 * import { mintProphecyNFT } from "@/lib/contracts";
 * 
 * export async function POST(request: Request) {
 *   const { recipient, tokenURI, score, occupation } = await request.json();
 * 
 *   // Only do this server-side with owner account!
 *   const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);
 *   const walletClient = createWalletClient({
 *     account,
 *     chain: base, // Base mainnet (L2)
 *     transport: http(process.env.BASE_RPC_URL),
 *   });
 * 
 *   const result = await mintProphecyNFT(
 *     walletClient,
 *     recipient,
 *     tokenURI,
 *     score,
 *     occupation
 *   );
 * 
 *   return Response.json({ success: true, ...result });
 * }
 * ```
 */

